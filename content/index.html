<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"02e3f21501ef86ebc71b1ba832ce6621ff711deca97752bf90a259abc9463fc9d914124c0ff2fe9eb703955d2cddc155e2c69df8e8f2a075951e44464b2ec75e994352bd75b17b41796b23c062fb652ffeea9a86c2798e818820a5c6859e66e28cbe36a4bb43ac7ce3cfc7b0c250b19f7e63c278f541c0dc44494f9c8669b9a7c8182fc49b075bb69b04b87f61de6f219fe5fba6b087da9e8930b6306fabdb82be0a80c3f1a3cf598d19cfb07a971e7cd01539f5abe6f5a7728c364972fa426380fd895ee29ac7c01b7fb49b5c7819c792bcc668a4aaa17aafc103e9584d058a5ef23c04738462d877d7553eef181a90b9a6b997b010ec70a50b8f19a78a639550e6bcb09314f7bd3804be1ef73f2d8cb9e8c6dc9cb73116e0f5e8003ad9a2c9383afa65543112f37e65012f6800340bb25b558efd044acdd480b278c6eaf4b638a1c27d30973078cbba3b60bfc10166283b3f320cb091621b6078ae70a34c8c165d202d3913946ef480b253e2d08e6f259bbd5ceade439f21d7a4e88c1c199eee095417e99b6a6f2a1646921000bf03f03cd80f24184ba7bd8319760786ec8b50af390420d92d6d31867e9aa4d228ea881c7a0ab9691324d15579d15280d2d065e2165b1538a081374fdf63914bbc0580075aa19f57805c342c5bd031b0c3df018c7e75370f8f173fd9b0b5f77cc18ad7d927d4b409e0a13ee311d966e37485cc22789f2f442c2a60bf2ee337cb81a6513eef4754a6560aab0a91bf8b45400db3e73ef730d2f714f233f2e7c6dfcf72b8a0e3b98d77f2726969ba3230c3ee070bab75b2c4f032c32ff19220f0648eedbcea56da8a35fccc84b7c3d663c06cdef7ece69039470c3883c51db2386b2eade5e3ea75d7e04d61b48061086b0ef8f37932e4ad508e6e5be4f0dcba2707a1d4ad13bb6af6015045d254e107b647a2980c4c22f976e4434722edb876c1afeb9ed03f0f103721ac0e547f9739accc6973100328672b438207a6c0a72e0fd6f354c568ba27a4c8efbd0c2dc65c2f3bbcb3fbdd8f859c9a0f59cb4d42fa4290e979d7ec7ad125780ed183fdf38872d44d992e5832b3a7de12f8b56aaed1453ee06e25f2c641680f1418e7cc14b49620710a79aa8662aa2d96d0040a1b83b3a532d490c1657cf7b40fb03497b9d74df2855b14a331dbb915f5f52b1750728b40d6f30778099fc1ea3f400e654d09a0dc6f3912e7e633923c508f1f84310ca3c47522a1c63ddd6c75b1b7c4555a84e58c1be9bb2af8a0a6691e46a7ca92acde2d4c52a72fd563c9f66470199f708b9bbfe9d9cfea5fc53e43bbc0b2fb15d56a95d1a2b0001c4d73556a881c4a907edab5ba0169fbb6e8067fcc891bb17ee88bb2ccca62bf8cf5276e10942e79831f358c488742e68bd0191304ac53628acedf0fc6dc45f4ff0e31e49fc97f95c52341351ef76490d5522f5c21ddecba0192d1e1f7d05f898ae2b75f03176ccf53651948950c3b749579b3803cf84a037491c9d29f283723c4f865843fc5d7b51e988835912ffe496456f71b2e37dfb7a9fbb98a4bef8f3a35dda3cc372cfe44e81f0caef73acae780a410a40c1c364a66da031ad2cbf74d6cd2516b98d743ad5e01f1878af0314e220d8ce4975676a1a81c932b698b479b3d0471e91f7da73544b6d34c6c539a7ce16d54e7658ef9b683cf0e589c2f3891fb5b5d3b8c333147db5e5288b78af38e175808ce14b84aad1e91f91fbe7183e12e689716788bf1e7ea6ed981c722615d3520a6b49a5aa63f0030711a75df2d5db22403804b382236d9f5279a6c057be233d4d8b733afbaab7568aa8358cdb8232b116468e70157351383fe809579002f8ebf0f07c6cd50c14908625b7ad2ef8ed787d2fe1c33262a9111039efafda5b8dddb98e960dba60aaf5327097b47c81a48e9963c41efec8ebdd737683e8a9c8efd8967ab3198ecf2fc7f751d6b6d2a88c9402438b17243dc3f6c56351ad7e47d35ce627a0e58850a4ab6a97980fa3f821940af0bc9806d90b5b1240a5422eee61d6314a441a0867f3cfe0ecfd8099ec922298b046e8319018fa91a2d367b5af69ec4f2ba0cd68300ba83bf3545d2e44348f552e09807743ed6d70591c279398976d6adf6f26ee3ec5f270d355bcf1690ae3a0575091c1f8caccb6ed9f6f259c2984b5a80c8c96e3499dc4852218e1dd61b849b0bec4012385818ca6622d75a682730c1f4c1448a1b3d2fe16b15b0053a00ac6703be1702d5fbb6e5fc476ad4846f172c06f6487bd56383e36966a253f2d92edd310ea14e13ba9684beb8f2976812083ccad59d835f7a01d45ac54e35cd08832f6c812f239b84f63096fafccf502aaba7323fc4cf0d5806a73ae3b5b76dc696ab691321dd4235ecd5aed55f47e7378fb9f3a02c82a38e6aa883d4c680b68ae7652c36d1705f489e4a2ece0e9aa41f3a9dd0fc65e1fcdcc64675a87829c84365dbae6d1d8372701dfc756a0278f04dcfaeffcdb41de2d1df000c5e5914fbf199f6bb49b8c297e54db70d1950de3520b4f67666165e89097dbba8d403fdbb25b85f5523dc3e7416cc2e3bc20ca7ab4cac0cec56a48ec3e67f12c82ef92afeff065ece58d02d20279f2a2b8e689a8cda6f46667d695091d13da93de851c361dc09beafe684170e6f2776ee6da98b4fa3dc6c1c0d6c87db68e3494a6e75832410aa45de17867e800e4cd553d7de6cfff4028a321c70d37d3358f5d8a2f80e0f2c303f84e186ad10bad042fea7dca07fb883380c73d93ed063608d31cdf297a37b81cac34c7698b72f72858133013e94f1ea40b45ceaba6902df93d98a07e6646a2d0222e1d4550ce44017b1420da0fae8231f0b33dee1f2f94ab6882a92cd1ed1e5fb52f9bf87adeab9aebce236f9530396224ff3e1d469ab5ba97a41039414b80a3a3da81473800b51c60c7f9edc0f32d411f8066f6a14a4f258329d5e4e4235ac40423e112d1d4a11788030e93314760044c3bf39b715ca24014cf94cd0cafaddcb794de7630639e07ab3621d674c3902a931be91c25dbe04f4a7c105368cc5abe76181229c6b779b0277c831087f9a9719aee8ed2e7c7b3d49e10a8dbff076a55592ea6b70d42fa40ee911760f2a8eb0705ce17f72a7035635c57e6346f0490d29beb528fd103c0aeafc825d4bcbfef4f527d493c433af1f75a0f2ecf00a48a06df50c661975dda57d7f16566e0f1c890e90b668debf4c2be5e1ccf6e029fe9f6d88c93029c5f7145438945426e2adbee1e37d1ee5bbd60d03bd9b1f85cd9f6848f3dcdbc77f79f399b9ca6c2cb6b7957e274920df75100acb82b605a1f619e6b65ab2baede021912f4daf7de5724015e167bd25a4408247756ab9b995cfb2cc3222a84028d4c97bf5b9f62bef20a6f7925a26bd7b78099b5d3f49f21a218cb9988eca1e31f91643103e49355752cb9e3e24ae27acb3505979820d487f8e7e4d1d4ec899728c575c4e0b620393ce597bbcd80bef7865fc54ffa27007844a4c6bf54a723da57a08ee7dfa5fd70dc67a70cd9c2ab06638731946d4a149f71034bafc4d96f30b513e435d66b0087d3ad5af26011d18aceb83f0a8d9c65cdfad7b3ae1ecb1208fb14cbce79e78b129c70d82c31527ba64f1699730510e834d94ef08f1e1e81a16ae8476360fc62992607f2c96349ed9909ef821b01d144d73a977ac981c3c93adc31a792267f84c9428b24eef0b64fabf3eb8beaac062b5516572eef4820a7f5700db29d3f86ea543633eccd080df3f8641b7d3f6309be3f59ffb38fa45d539dcdab4f44c306e000ace7ef494c4454cad3eb87069c264a9c467a7193df8fafcdcb861f6690c78a777e6ecdaf06412289ff9533d3a62c6fc8c47bc4110f7dc2968d4af883fb5e7b4e325527773c2d6fc265d7095aa51e344ec2423c4e90bb7a792b0f9f6684db4240f7da34b31d6efd8892383076faa0f6a30833a4b69073bcd1c852a83c1d954a092452be9c4454079a15acd077b3e16bd10af61c5fe7874556e44b47e83273b67aed54b62d5d9bf590fb7c3514de243a8f5c3e6c307e36b13f6eff0ac6ec18363060bf379df41c11c397f22f43bf0ff321f54e71c78de2e56e68ffde7042c619a18f47331779d6eab4a8b720e7ea7e3c1513a0f42129531d76f3a168b824599f5933d03d3ab0fe750f53353e4db57adbab4d83854167e0c676bcce024a5eee8db0b307c57d7ecaf8bed177c65a91681c1b23fb0e50df131d5aa35b709f80e955c2247649d7f86991b75912dd81bfb60ae8f0a0a80157c1c922e5560fbe7c5bdf27c655ca6e26ac1e3d030e8a17f06e4290d6a83c8a7637298c8af9164e57e2a4f42e822aea55ec5516d927c226e873e39fac17ba894116ed6092d92c1cf31626adb6ccc8aa814b6f8cc30c101ac7d863ec9408710df518b46bc853d1ae6442c6af1538ca3589b1800701d166ac0ec0f54527b5fbf63c403bd76276539cb21824f154f6945b2340dfb75d03c572d9ce1a84fe7debbe1e8bc1d9d49c5c00c125316678c4b074838f1aae011a02fddca13ae1360e070a8bd77aacef7b32a2a780ed58eff0209005fad942c33580d3211c9bef205b3038f2616457c1e8391c0957d7768e8c7d8394a1b3e82a246220e42712a685378605263216a8de27868c769aab8dc187355a94637291e5b9cdf769d88c15be8880f5356aa6af4d611c38d78d76c9c5188f65b512f73316c6c5873369a54f3cca612ef983e851cea2c0f8a3af2dc5dbd9bd26e7e28beda9f78e9208dc376b58f37cc6b265e52bdb6d02cb8138c4f0585df1b13528384f7e5b428127ea20cb1cdd78fbe60700a45336b45c6b8f5af0ead282e8fdb53195e47fd49d4e471d43d4b4843087aafd59137e57310c59180e34e810dae5fc4fe4fba734866d85a8c583e9fc477595bce0b3944c552de164ec9224f0a4cfc160e39f7a7c8cc4f79aad281cd8a0d9502a2ded6b7f7edc6430a735249d4da9da8266a219e9eea55db4b82084360930e7967d3a11603b1b398ed531274995a9620936c6899bbf261b608feec6837c9a4eb464bedbdfc3b30b8fdace6a4287e4c9803d69b93e66658185bb61103c821da0e9ec51d91cf1adae3f11e4a641f8c5840d1ac73a7825621fc63789ec3a6fb25f2acdc4abe0adfb78ee095e5ebb1af90d93c440fde51aef611e6e6057dd0389d0d2d6ab5c866e73371d46ff5b915ce2aa5a129e0513841eb3ff0a0a65318a4ab6bd584b8cc6faa6655da07831f61db74b7309cd0062b5054e2fc1bbabbdfdc6e412a5896f041395f8129b46f5f0c60e4304c4fc7eeaeff6507a8be902048b4180e5d23447444dfccaec0622008c0b0c314deb21d50b254ac62b3b8f94b62cb283c421548a38416620d0f7fd920a17f729805cd014e227b7e4c9c85bc0df07fd016970e6df2e592635bf65763ad6b1de90a9f8f32045dfe29cc932f5292afd41a6de90b72f4744ca736e8bcf7f8fc10b506d720350bd5bcaac2ddf84c1fa50fc613d211b4e760cd589ecd497b45ca6e10726d240771f73b06ecab8a21d715ca146b1cf2860eef7101d7e0601f9be83f99ea0133209416d1d2506531ea07cfd7421e755106d727da1ff2d6a0b84aef37dbc4913d8dca2e92f9e94527278992b5a5c124a6070d34faa34deabb4a20046f214a2ad1b3f660eaa59931de52eb7389aa98d5c1ffd5f9bad6ed8c75b158f0ecdf5d606c737bee3c9eb0292fb0c526aa38af16b6fb467c9848f8b6694560a1b5b7f19fb92682fc537784060ecf5d3083bc3612fe995b06e26b1e94e092a2b57661a7b2cc14e11ebde0563b4eee89c15b23d1db18211bcbc5b8686862048654fd03d0f751d6136498b16462def3d47fb513cccbeed7853b0ead0406f69a683e974d9fa36ecf5c75ff9adde3fc075a86a42492bc5ab723797ebc27a56dc9d0dee850c9c175fcf47ec74a7d594d8c18e6ac9b150c0e021404830ee7009732589aac440efdc7a8a98988dc9d28de9771fc90cab5f60c65c8b3b9d215ff9153b4f2fe13046220fbc7aba6fa901da31466a759871cfc946c630681acde6c18677c59702d2ee19b43a431d8f16c0faf4352a4657bcba78bac36f042b76321cf86514d89f836e96d604a5aae41f285d07b23deca426919cfcec97f24a2417244c765c2b71fbe398be5f572fb1b858a5bcd7826ac419f34cad0b6d15b24b407a112774892eeedbc799a2b5873cfb8651520b3d0f3efbc6b7f03d955e6a50ae607590d463d84667e91730603265f7af87da6984843553eeac5b1a0a6fe9a91344ad3364a29585c7b591cfd8703c0fb9d04b3c54c6fecfc7ad2bf72cc423903f59ed1762b793bdb6d1b951793852713d46bf8245b489ef9e81a27b55885500e4b990264cc30db00d7d0229eb0aa096f0c1d2e4644470132eb3b28bc8772ba89b5ce68094b2a1c71e973b9a50e7967c0fabac54d5a785a6aa8e8e52203f0292b0fe5751152babc1414379061883be92ac3958c38e244643ac2599e8b3ae38484700ff5c8281735fe7bf4c513a223ac9d1ca0138a786a49b439fc7d7d76a5eb63f66d8b71e8e939cd0081dfa000ed5f6e9fa8b56767fd2c85e43aeb027e15a90d4d8b36f195e8d186a471634cc956162c6d2464dde86ec14c85659d229cd716c4579e313f06ab3c23d358b98fb416d7b4cceaaf7455f85fcf451268c0bd0a2482a002f428f20bdf538c70bb9528c0459513bcc12f0094fee7f3f979e5b2fa76b08a10e9985aa9eb0d06cded96e022530945d6f317de60fad0cc7578304cc369232cb0c0c552de8c57de3c53db1ad154181ce913170ffc09e6bd9dff6f308f58ac4d09af7159b6cbc19c43c1e504c94f9d38cfb09e35ebf3965014a8d0ded92f580562c6151f295eede08d53d4cbf6aca7f5fc17a7b288e179963d963e245d225bdc8331c67f4f9ffd8e05dd63a460fa761a7b9d7e244a606137ecc487adcdf18bc1818a57fd2c374c4b0b3301cdea9608e60a502b99df0bd3c9bff1ee8f3ee4fc96e9026ed253712dedb76b89c8b3a9939cf2c8a1d61a89d44f3ed74dd7ef24c02b3e1c8ebd64c9fa51fffd0b32cb3ee0ded6104a5fdca3eedad647fc626e93b564c8676b04dd2741b004e27c448c8351eb7293c19815939cbe030ffc55fb631111abafb8fb0b52321d6b05255a7d0c0cefb85949a954e34d381aa9dcc5c2dd15bc222b103e4d8bde3b4f71d9b996d972e3cdb746786e1a8f880d02eecc71d27a8cf36b821947ce75ba0c6396d71f56f8fdfa34b63257f9a65ad64adf5e9103b3854bde949616b431a05dba3ef4260600366abfe0e7a5eae297afc6a20f6fd18650754a956ae87817a2451b17671b64bda538d3fda7b68fe26d8b36a72d42737f783770503bd321bd8b8307c97aa350e13716def661548a3a7ad07effbeb3ed0c67a406bfab69ef4f52cdc5860a28618b20118b6247990fb04e275bf9e4bdfd75a5ec9206fe716e812fd257cbbcdb5e5d723a67e11e0f9fd09a47e69794e483a5b81faac695b48efeb9fbebab319f8e1e3970ad64659a559ec020c153f710975bd2d5cb94c094f9842aa74aa6942e3c936f74cf4c8494d0e524ec2e9c10919c94fd0599ef5222a178e50c941df4b3dcdd2d59707460592f0e622e41cf9d3a7d3fc6f40467007ed9e8ac689c1ebd2ffdcdbe11159aa5c59623a67e06ad712a5f76c477f97c033f03c11ecb0838df0afcafdbcad1f98ade94a5ae2346fd9505e3a563ebf85df580822ac7993a1be1e12c6f4619b3866966e3394961576c17241c9085f0b333fb6fa13c36896eceda39b872433bac3015c22cf974ad5003bb276ca955d5e8b6a403dc61beffddc9c3c18cef3bcbb259f7409311f714def1f8402abcac3fa65ca08098ad906ae0af2660fd3814b8d1b6d8a915cf3afaa27b2e370948ef48d8e126f19145f490bb8f08c13e10476a29bdd5ff6167cf8566764dda393e86285837320ecc556816d21576329db17a3df2dd15ae5aa7bb2d4b65ad23b7a543401fe9e70b1d61fccb7182308cdc18a8eec485fdf5529c08c8cdb2bb181a17f4cdd0b05e192f2562a7f2291c8b99771556b2a6c3a1c9c0f24d9cb6c49198461d0d7f70e5145e3b993b4cf36343ca9a97d2673d6080d4f20ff402e63edf7a0fbea543bcc2f76e7a0f0eda64ffdc2db3014b38d1a793a36b1259fdfdd320e1f87b89492a28810f5fef14591d911fcb7fd703af5194abc49366960d6ebfbb7465b05c2a1e0daaa250e2220c567e70b0986851d57642dd98336c224c83ce39d83e2c359f4c18e1e061091dcf3c85f02457cd9de516629d19df95398a6014a5a9c75706cca0517a0282412843bf987208f5be63ed0da02a4273efb52dd1eaff4796eef211bdde95b21d84f832aecf3a902830e3020f14d6d3a26068b41aed1bf22885c8dca4ec7d29e44897680f67fbbbd64312f7f03582d07976098ff98aca94a83f949c1cca4eab4f8923ce494381ecba33f8c5714b24279232adaada6047144598da477930adb89f8280944436c4c82c86ae4f664570bb2a4fd76d05253052d9e81750fc46139b1bbcebf7c6f31b75ae8502f584952630907947a0b165097b59d8fcd72820e721537ef80b6d3145c32563311d36bdfcd6b3fa4f4ee486b63a274758a4e51775b65144f28f2651f0472530de27a15c60ed1ea0dba584ea970687b86b8e262f92f63a05a06767cf6b3c1215545ed2987dedd184b76c178ffb8e3abfc4dddc51d8e8b4b9b7ad9354836fa45b1d284a7dc2bd340000b0203e2eb350e619338042d4327dd1bd980a8338e992922052d15aef02401e0151afa6a7198c2cabea9a7dda9d30f6cf26a928202ed279a4ca18c66f3096d26600edb2c16323d97578358e2ed190b338b75293f32f1162cac8d9da8fb81e96c8b538d03499b80055717f60da2f2e76313cecca6d0427e9e5daf4134f4e8b77b7b093a449dcc6f4ddbe13e1bceea08e1b99e2183ac8a1a1a6b84b9e6342b5c53d5c60af6a9341824c15c66fa208abb2cbd5a51b7b97591e1ac6f84db811032607877b231a0a3fed92725b04d635e620823fa46d521501a29478c03087b898f9e742f06c8e3083be80c1956240490de841a96ff43f79a84002faddbec456a01c5e4c40940b54f3aadda105ec7778aedc7981504331d45a2010c3bd012e4ea01a085720f73e876a1e60608b13fc78ee1927d6b750a6e048b99ae23a3bb00e8c00a68e2ff7c463ba4d5711941872cf1c5fff62f2e030cfa49a1ae92b82f5b10daf85af586f88482d552ccdd4e2f80b53e6d3a3dce65c52d7b3c34441e3acad0bad638310df808a13bb2f7279a8ad4594aa718830b1d372275d620f4ba8fa01151f2ddd6a078101abd1d9a9a9053dc9e192a5906997d475051ba32ad30d4d52eb1c2670f1a16ca93eb9e2c3892b32990f41852a68c658ec794fa2570252315ba85cd29b758fa47655023f176957e3075df579ddb1e831bcad99a073bcc00566f70d1de8c725afb5eeb8ed9fb8cc68b55aa68c5acbb963df2607cd64e187384d62700f6098da53046eb65439191801ff883516fe9fa2664a10106e34576d7d37228c154bd33ce625c8e4235babd67e5f97eb22ecb3c46533a9073f68d03b41fc5259fe34836a1a8480f21262eade874e9f7aa150e127e11a2d19621f088a36e6c079c2d984ddd69fc9756ff8ddd73e43d9733b6d593f12cf66eb516583c320d4d1ca81d13599a3e93d4753beaa3e86e77ac13aeac49a4ffed02ce89062b9626117451bf02b2cef7fb8b59c6c365eda59187e0086ccd0c3be7c2ce5d36826501d632e477b66857e906d5814eb7e5cc93c4ebea07284d7397c9b4b40971fe5521003adfe56914c4b5c8425f98724bb3d3e60acc07b97b8a8a20ced0349a6e04412f060f67236361b7ce47e2372b8f849ecc896e35e943398655835305d2f0d25c15a8ebcc1d6edc64edfb06457bd4872a809575d96750230afb2a04daf748675105ba6ff148cb33aee9c40e838dc57df8739883222a82c71d37e1ae94d7af0af26182174be347f1634b57ac4dbade0e00ddbb4ce936b9e8dbe1794090061dddff861c8c1332b66edb2208772f1e6a1b749272cde38fd51eb641e66d06862c4b11ee47d554a686731a5d1b2a5ca29824e7705f860e5ee20c5a5ba079da149b0bb622d32395da62d01255665","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5306e405d5c84ef1710eafba598f7b10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
